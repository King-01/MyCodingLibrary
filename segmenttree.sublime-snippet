<snippet>
	<content><![CDATA[

struct item{
    // int m, c;
    // long long int su;
    // long long int mex, pref, suf, sum;
    int val;
};
//O(N) preprocessing time and O(logN) query time amortized.
// take care this implementation is 0 indexed!
// segtree st;
// st.init(n);
// st.build(v);
struct segtree{
    int sz;
    vector<item> values;
    item NEUTRAL_ELEMENT = {0};

    item merge(item fi, item se)
    {
        // if(fi.m < se.m)
        // {
        //     return fi;
        // }
        // if(fi.m > se.m)
        // {
        //     return se;
        // }
        // return {fi.m, fi.c + se.c};
        // return {min(fi.su, se.su)};
        // return {
        //     max({fi.mex ,se.mex ,fi.suf + se.pref}),
        //     max({fi.pref, fi.sum + se.pref}),
        //     max({se.suf, se.sum + fi.suf}),
        //     fi.sum + se.sum
        // };
        return {fi.val + se.val};
    }
    
    item single(int val)
    {
        // if(val > 0)return {val, val, val, val};
        // return {0, 0 , 0, val};
        return {val};
    }

    void init(int new_size)
    {
        sz = 1;
        while(sz < new_size)sz <<= 1;
        values.resize(sz << 1);
    }

    void build(vector<int> &v, int node, int lx, int rx)
    {
        if(rx - lx == 1)
        {
            if(lx < sz(v))
            {
                values[node] = single(v[lx]);
            }
            return ;
        }
        int mx = (lx + rx) >> 1;
        build(v, 2 * node + 1, lx, mx);
        build(v, node * 2 + 2, mx, rx);
        
        values[node] = merge(values[2 * node + 1], values[node * 2 + 2]);
    }

    void build(vector<int> &v)
    {
        build(v, 0, 0, sz);
    }

    void set(int i, int val, int x, int lx, int rx)
    {
        if(rx - lx == 1)
        {
            values[x] = single(val);
            return ;
        }
        int mx = (lx + rx) >> 1;
        if(i < mx)
        {
            set(i, val, x * 2 + 1, lx, mx);
        }
        else
            set(i, val, x * 2 + 2, mx, rx);

        values[x] = merge(values[2 * x + 1], values[2 * x + 2]);
    }

    void set(int i, int val)
    {
        set(i, val, 0, 0, sz);
    }

    item calc(int l, int r, int x, int lx, int rx)
    {
        if(lx >= r or l >= rx)return NEUTRAL_ELEMENT;
        if(lx >= l and rx <= r)return values[x];
        int mx = (lx + rx) >> 1;
        item f1 = calc(l ,r ,2 * x + 1, lx, mx);
        item f2 = calc(l ,r ,2 * x + 2, mx, rx);
        return merge(f1, f2);
    }

    item calc(int l, int r)
    {
        return calc(l, r, 0, 0, sz);
    }
};

]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>segmenttree</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
